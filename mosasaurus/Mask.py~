from imports import *
from Aperture import Aperture

class Mask(Talker):
  '''Mask objects keep track of the collection of Apertures
        that should be looked at for this observation.

            This can be thought of as the mosasaurus' checklist
            of slits to investigate, and bookkeeping tools.'''

  def __init__(self, reducer, **kwargs):
    '''Initialize the mask object.'''

    # decide whether or not this Mask is chatty
    Talker.__init__(self, **kwargs)

    # connect it to other parts
    self.reducer = reducer
    self.calib = self.reducer.calib
    self.ccd = self.calib.ccd
    self.obs = self.calib.obs

    # set up a display
    self.display =  self.reducer.display
    self.speak('created a mask, to store extraction regions')
    #self.setup()

  def pickStars(self):
    '''Open ds9 and pick the stars we want to reduce.'''
    extractionCentersFilename = self.obs.extractionDirectory + 'extractionCenters.txt'
    if os.path.exists(extractionCentersFilename):
      self.speak("Extraction centers were already defined; loading them from {0}".format(extractionCentersFilename))
      x, y = np.transpose(np.loadtxt(extractionCentersFilename))
    else:
      self.speak("Please should pick the stars you're interested in.")

      # create empty list of extraction centers
      self.xcenters, self.ycenters = [], []

      # set up a loupe display to show an undispersed image
      self.loupe = self.reducer.display
      self.loupe.setup(self.calib.images['Undispersed'])

      # add in an option to pull out an extraction center
      self.loupe.options['a'] = dict(description='[a]dd an extraction center',
                                      function=self.addExtractionCenter,
                                      requiresposition=True)

      # add in an option to pull out an extraction center
      self.loupe.options['r'] = dict(description='[r]estart, clearing all centers',
                                      function=self.resetExtractionCenters,
                                      requiresposition=True)


      # start up the loupe event handler
      self.loupe.run()

      # pull out the extraction centers and save them
      y,x = self.xcenters, self.ycenters
      assert(len(x) > 0)
      np.savetxt(extractionCentersFilename, np.transpose([x,y]))

    self.xextract, self.yextract = x, y
    self.speak('extraction centers are')
    self.speak('   x={}'.format(x))
    self.speak('   y={}'.format(y))


    return x, y


  def resetExtractionCenters(self, pressed):
      self.xcenters, self.ycenters = [], []
      try:
        self.centersplot.set_data(self.xcenters, self.ycenters)
      except:
        self.centersplot = self.loupe.ax['2d'].plot(self.xcenters, self.ycenters,
                                                    linewidth=0, marker='x',
                                                    markersize=10, color='black')

  def addExtractionCenter(self, pressed):
      '''from a keyboard event, add an extraction center'''
      x, y = pressed.xdata, pressed.ydata
      self.speak('adding an extraction center at {:.1f}, {:.1f}'.format(x,y))
      self.xcenters.append(x.astype(np.int))
      self.ycenters.append(y.astype(np.int))
      self.speak(' {} {}'.format(self.xcenters, self.ycenters))

      try:
        self.centersplot.set_data(self.xcenters, self.ycenters)
      except:
        self.centersplot = self.loupe.ax['2d'].plot(self.xcenters, self.ycenters,
                                                    linewidth=0, marker='x',
                                                    markersize=10, color='black')



  def setup(self, visualize=True, remake=False):
    '''Setup extraction masks, starting with the x and y positions selected by user.'''

    # open tool for use to pick stars
    self.pickStars()

    try:
      # ultimately, include ability to load extraction parameters that were already defined
      assert(False)
    except:
      #load the apertures, if they exist already
      if os.path.exists(self.obs.extractionDirectory + 'apertures.npy') and remake==False:
        apertures = np.load(self.obs.extractionDirectory + 'apertures.npy')
        return apertures

      self.apertures = []
      # open a dispersed image (take the first one)
      imageDispersed = self.calib.science()


      for i in range(len(self.xextract)):
        x, y = self.xextract[i], self.yextract[i]
        a = Aperture(x,y,self)
        self.apertures.append(a)

      if visualize:
        # create a finder chart of apertures
        self.loupe = self.reducer.display
        self.loupe.one(self.calib.images['Undispersed'])

        for a in self.apertures:
          # display the target positions on the image
          self.loupe.ax['2d'].plot(a.y, a.x, marker='x', color='black', alpha=0.5, markersize=8, linewidth=0)
          self.loupe.ax['2d'].text(a.y, a.x, '   {:03.0f},{:03.0f}'.format(a.x, a.y), color='black', alpha=0.5, ha='left', va='center', fontsize=6)


          #r.addBox(a.xbox, a.ybox, a.wbox, a.hbox, color='green')
        filename = self.obs.extractionDirectory + 'genericfinderchart.pdf'
        plt.savefig(filename)
        self.speak('saved finder chart to {}'.format(filename))


  def createStamps(self, n):
    '''Write postage stamps around the spectra.'''
    print "   creating (unfiltered) postage stamps for all science images"
    #for n in self.obs.nScience:
    print "     cutting stamps out of ccd{0:04}".format(n)
    this = self.ccd.readData(n)
    for a in self.apertures:
      stamp = a.stamp(this)
      writeFitsData(stamp, stampFilename(n,a))
      self.speak("saved stamp to {0}".format(stampFilename(n, a)))


  def load(self, n):
      '''Make sure the mask's CCD data is set to the correct frame.'''
      self.ccd.readData(n, imageType='Science')
      assert(self.ccd.n == n)
      self.speak('set CCD data to {0}'.format(self.ccd.name))


  def extractStars(self, n, remake=False):
      '''For one frame, extract all the spectra in this mask.'''

      # provide update
      self.speak('extracting {0} spectra from image #{1}'.format(len(self.apertures), n))

      # load the (entire!) image
      #self.load(n)

      # loop over apertures
      for a in self.apertures:
          # extract the spectrum in this aperture
          a.extract(n, remake=remake)

      # hzdl - testing:
      #self.apertures[4].extract(n, remake=remake)

          #self.input('just finished extracting all stars ({0})'.format(n))

      #import sys
      #sys.exit("Breaking here. Check it out.")

  def extractEverything(self, remake=False):

    '''Loop through exposures, extracting all the spectra in this mask.'''
    self.speak('looping through all frames and extracting all spectra in them')

    # extract spectra
    self.speak('making sure all spectra have been extracted')
    
    #self.extractStars(945, remake=remake)
    for n in self.obs.nScience:
        self.extractStars(n, remake=remake)

    # make a movie of the extractions
    self.speak('making movies of the extraction apertures')
    for a in self.apertures:
        a.movieExtraction()


    # add wavelength calibration
    self.speak('adding wavelength calibrations to all spectra (if not already done)')
    self.addWavelengthCalibration()

  def addWavelengthCalibration(self, remake=False):
      '''don't extract, just addWavelengthCalibration the wavelengths and resample'''

      self.speak('creating wavelength calibrators')
      for aperture in self.apertures:
          aperture.createWavelengthCal(remake=remake)

      self.speak('adding wavelength calibrations to all stars (if needed)')
      for n in self.obs.nScience:
          # re-make wavelength space here, then for each a you can have this new wavelength solution. 
          for a in self.apertures:
              a.visualize = False
              a.addWavelengthCalibration(n)

          import sys
          sys.exit("Breaking here. Check it out.")

          stars = []
          for a in self.apertures:
              stars.append(np.load(a.extractedFilename)[()])

          minx, maxx = 0, 0
          for s in stars: 
              if s['w'][0] < minx: minx = int(s['w'][0])
              if s['w'][-1]+1 > maxx: maxx = int(s['w'][-1]+1)

          for s in stars:
              #print i
              mins = int(s['w'][0])
              maxs = int(s['w'][-1]+1)
              s[width]['raw_counts_adjusted'] = np.hstack((np.zeros(abs(minx)-abs(mins)), s[width]['raw_counts'], np.zeros(maxx-maxs)))

          def align_lines(stars, line_range, offset, line_pos, plot=False):
              for s in range(len(stars)):
                  #print s
                  corrmaster = wavemaster[line_range[0]:line_range[1]]
                  corrstar = stars[s][width]['raw_counts_adjusted']
                  arraylen = line_range[1]-line_range[0]  
                  initpx = line_range[0]-offset
                  corrs = []

                  for shift in np.linspace(0, arraylen+offset, (arraylen+offset)*10+1):
                      newbit = shift%1
                      therest = 1 - newbit
                      startpx = int(np.floor(shift))
                      corrarray = np.zeros_like(corrmaster)
                      corrarray = corrstar[initpx+startpx:initpx+startpx+arraylen]*therest + corrstar[initpx+startpx+1:initpx+startpx+arraylen+1]*newbit
                      corrs.append(np.corrcoef(corrmaster, corrarray)[0,1])
                
                  finalshiftind = np.where(corrs == np.max(corrs))
                  finalshift = np.linspace(0, arraylen+offset, (arraylen+offset)*10+1)[finalshiftind]
                  line = line_range[0] + np.where(corrmaster == min(corrmaster))[0][0]
                  line_pos.append((line+finalshift-offset)[0])

          wavemaster = starmaster[width]['raw_counts_adjusted']

          align_UV = (660, 680)
          align_O2 = (980, 1030)
          align_H2Osmall = (1240, 1280)
          align_Ca1 = (1370, 1380)
          align_Ca2 = (1380, 1400)
          align_Ca3 = (1420, 1460)
          align_Ca = (1350, 1450)
          align_H2O = (1680, 1900)
          makeplot = False

          UV_pos = []
          align_lines(stars, align_UV, 30, UV_pos, makeplot)
          O2_pos = []
          align_lines(stars, align_O2, 20, O2_pos, makeplot)
          H2Osmall_pos = []
          align_lines(stars, align_H2Osmall, 20, H2Osmall_pos, makeplot)
          Ca1_pos = []
          align_lines(stars, align_Ca1, 10, Ca1_pos, makeplot)
          Ca2_pos = []
          align_lines(stars, align_Ca2, 10, Ca2_pos, makeplot)
          Ca3_pos = []
          align_lines(stars, align_Ca3, 20, Ca3_pos, makeplot)
          H2O_pos = []
          align_lines(stars, align_H2O, 30, H2O_pos, makeplot)
          #Ca_pos = []
          #align_lines(stars, align_Ca, offset, Ca_pos, True)

          known_wave = np.array([6867.19, 7593.70, 8230., 8498., 8542., 8662., 9300.])
          x_pos = np.array([UV_pos, O2_pos, H2Osmall_pos, Ca1_pos, Ca2_pos, Ca3_pos, H2O_pos])
          feature_num = range(len(x_pos))
          for i in range(len(stars)-1):
              fit = np.polyfit(x_pos[:,i], known_wave, 3)
              fit1d = np.poly1d(fit)
              spectrum = stars[i][width]['raw_counts_adjusted']
              specindx = np.where(spectrum != 0)[0]
              stars[i]['wavelength_adjusted'] = fit1d(new)[specindx]
              plt.plot(stars[i]['wavelength_adjusted'], stars[i][width]['raw_counts'])
          plt.xlim(5700, 10800)
          plt.legend()
          plt.show()
 
          for a in self.apertures:
              a.interpolate(remake=True)
